import { TextFieldProps, CheckboxProps, FormControlLabelProps, SelectProps, FormControlProps, IconButtonProps, AutocompleteProps, SliderProps, ToggleButtonGroupProps, FormLabelProps, ToggleButtonProps } from '@mui/material';
import { ControllerProps, Path, FieldError, Control, UseFormProps, SubmitHandler, UseFormReturn } from 'react-hook-form';
export * from 'react-hook-form';
import { FieldValues } from 'react-hook-form/dist/types/fields';
import { PropsWithChildren, FormHTMLAttributes, BaseSyntheticEvent, ReactNode } from 'react';
import { DatePickerProps } from '@mui/x-date-pickers/DatePicker';
import { DateTimePickerProps } from '@mui/x-date-pickers/DateTimePicker';
import { TimePickerProps } from '@mui/x-date-pickers/TimePicker';

declare type TextFieldElementProps<T extends FieldValues = FieldValues> = Omit<TextFieldProps, 'name'> & {
    validation?: ControllerProps['rules'];
    name: Path<T>;
    parseError?: (error: FieldError) => string;
    control?: Control<T>;
};
declare function TextFieldElement<TFieldValues extends FieldValues = FieldValues>({ validation, parseError, type, required, name, control, ...rest }: TextFieldElementProps<TFieldValues>): JSX.Element;

declare type FormContainerProps<T extends FieldValues = FieldValues> = PropsWithChildren<UseFormProps<T> & {
    onSuccess?: SubmitHandler<T>;
    FormProps?: FormHTMLAttributes<HTMLFormElement>;
    handleSubmit?: (e: BaseSyntheticEvent<T>) => Promise<void> | void;
    formContext?: UseFormReturn<T>;
}>;
declare function FormContainer<TFieldValues extends FieldValues = FieldValues>({ handleSubmit, children, FormProps, formContext, onSuccess, ...useFormProps }: PropsWithChildren<FormContainerProps<TFieldValues>>): JSX.Element;

declare type DatePickerElementProps<T extends FieldValues, TInputDate, TDate = TInputDate> = Omit<DatePickerProps<TInputDate, TDate>, 'value' | 'onChange' | 'renderInput'> & {
    name: Path<T>;
    required?: boolean;
    isDate?: boolean;
    parseError?: (error: FieldError) => string;
    onChange?: (value: TDate, keyboardInputValue?: string) => void;
    validation?: ControllerProps['rules'];
    parseDate?: (value: TDate, keyboardInputValue?: string) => TDate;
    control?: Control<T>;
    inputProps?: TextFieldProps;
    helperText?: TextFieldProps['helperText'];
    textReadOnly?: boolean;
};
declare function DatePickerElement<TFieldValues extends FieldValues>({ parseError, name, required, parseDate, validation, inputProps, control, textReadOnly, ...rest }: DatePickerElementProps<TFieldValues, any, any>): JSX.Element;

declare type DateTimePickerElementProps<T extends FieldValues, TInputDate, TDate = TInputDate> = Omit<DateTimePickerProps<TInputDate, TDate>, 'value' | 'onChange' | 'renderInput'> & {
    name: Path<T>;
    required?: boolean;
    isDate?: boolean;
    parseError?: (error: FieldError) => string;
    onChange?: (value: TDate, keyboardInputValue?: string) => void;
    validation?: ControllerProps['rules'];
    parseDate?: (value: TDate, keyboardInputValue?: string) => TDate;
    control?: Control<T>;
    inputProps?: TextFieldProps;
    helperText?: TextFieldProps['helperText'];
    textReadOnly?: boolean;
};
declare function DateTimePickerElement<TFieldValues extends FieldValues>({ parseError, name, required, parseDate, validation, inputProps, control, textReadOnly, ...rest }: DateTimePickerElementProps<TFieldValues, any, any>): JSX.Element;

declare type TimePickerElementProps<T extends FieldValues, TInputDate, TDate = TInputDate> = Omit<TimePickerProps<TInputDate, TDate>, 'value' | 'onChange' | 'renderInput'> & {
    name: Path<T>;
    required?: boolean;
    isDate?: boolean;
    parseError?: (error: FieldError) => string;
    onChange?: (value: TDate, keyboardInputValue?: string) => void;
    validation?: ControllerProps['rules'];
    parseDate?: (value: TDate, keyboardInputValue?: string) => TDate;
    control?: Control<T>;
    inputProps?: TextFieldProps;
    helperText?: TextFieldProps['helperText'];
};
declare function TimePickerElement<TFieldValues extends FieldValues>({ parseError, name, required, parseDate, validation, inputProps, control, ...rest }: TimePickerElementProps<TFieldValues, string | null>): JSX.Element;

declare type CheckboxElementProps<T extends FieldValues> = Omit<CheckboxProps, 'name'> & {
    validation?: ControllerProps['rules'];
    name: Path<T>;
    parseError?: (error: FieldError) => string;
    label?: FormControlLabelProps['label'];
    helperText?: string;
    control?: Control<T>;
};
declare function CheckboxElement<TFieldValues extends FieldValues>({ name, validation, required, parseError, label, control, helperText, ...rest }: CheckboxElementProps<TFieldValues>): JSX.Element;

declare type SelectElementProps<T extends FieldValues> = Omit<TextFieldProps, 'name' | 'type' | 'onChange'> & {
    validation?: ControllerProps['rules'];
    name: Path<T>;
    options?: {
        id: string | number;
        label: string | number;
    }[] | any[];
    valueKey?: string;
    labelKey?: string;
    type?: 'string' | 'number';
    parseError?: (error: FieldError) => string;
    objectOnChange?: boolean;
    onChange?: (value: any) => void;
    control?: Control<T>;
};
declare function SelectElement<TFieldValues extends FieldValues>({ name, required, valueKey, labelKey, options, parseError, type, objectOnChange, validation, control, ...rest }: SelectElementProps<TFieldValues>): JSX.Element;

declare type CheckboxButtonGroupProps<T extends FieldValues> = {
    options: {
        id: string | number;
        label: string;
    }[] | any[];
    helperText?: string;
    name: Path<T>;
    required?: boolean;
    parseError?: (error: FieldError) => string;
    label?: string;
    labelKey?: string;
    valueKey?: string;
    onChange?: (data: any) => void;
    returnObject?: boolean;
    disabled?: boolean;
    row?: boolean;
    control?: Control<T>;
    checkboxColor?: CheckboxProps['color'];
};
declare function CheckboxButtonGroup<TFieldValues extends FieldValues>({ helperText, options, label, name, parseError, required, labelKey, valueKey, returnObject, disabled, row, control, checkboxColor, ...rest }: CheckboxButtonGroupProps<TFieldValues>): JSX.Element;

declare type MultiSelectElementProps<T extends FieldValues> = Omit<SelectProps, 'value'> & {
    options: {
        id: string | number;
        label: string;
    }[] | any[];
    label?: string;
    itemKey?: string;
    itemValue?: string;
    itemLabel?: string;
    required?: boolean;
    validation?: any;
    name: Path<T>;
    parseError?: (error: FieldError) => string;
    minWidth?: number;
    menuMaxHeight?: number;
    menuMaxWidth?: number;
    helperText?: string;
    showChips?: boolean;
    control?: Control<T>;
    showCheckbox?: boolean;
    formControlProps?: Omit<FormControlProps, 'fullWidth' | 'variant'>;
};
declare function MultiSelectElement<TFieldValues extends FieldValues>({ options, label, itemKey, itemValue, itemLabel, required, validation, parseError, name, menuMaxHeight, menuMaxWidth, minWidth, helperText, showChips, control, showCheckbox, formControlProps, ...rest }: MultiSelectElementProps<TFieldValues>): JSX.Element;

declare type PasswordElementProps<T extends FieldValues> = TextFieldElementProps<T> & {
    iconColor?: IconButtonProps['color'];
};
declare function PasswordElement<TFieldValues extends FieldValues>({ iconColor, ...props }: PasswordElementProps<TFieldValues>): JSX.Element;

declare type RadioButtonGroupProps<T extends FieldValues> = {
    options: {
        label: string;
        id: string | number;
    }[] | any[];
    helperText?: string;
    name: Path<T>;
    required?: boolean;
    parseError?: (error: FieldError) => string;
    label?: string;
    labelKey?: string;
    valueKey?: string;
    type?: 'number' | 'string';
    emptyOptionLabel?: 'string';
    onChange?: (value: any) => void;
    returnObject?: boolean;
    row?: boolean;
    control?: Control<T>;
};
declare function RadioButtonGroup<TFieldValues extends FieldValues>({ helperText, options, label, name, parseError, labelKey, valueKey, required, emptyOptionLabel, returnObject, row, control, ...rest }: RadioButtonGroupProps<TFieldValues>): JSX.Element;

declare type IProps = Omit<FormControlLabelProps, 'control'>;
declare type SwitchElementProps<T extends FieldValues> = IProps & {
    name: Path<T>;
    control?: Control<T>;
};
declare function SwitchElement<TFieldValues extends FieldValues>({ name, control, ...other }: SwitchElementProps<TFieldValues>): JSX.Element;

declare type PasswordRepeatElementProps<T extends FieldValues> = PasswordElementProps<T> & {
    passwordFieldName: Path<T>;
};
declare function PasswordRepeatElement<TFieldValues extends FieldValues>({ passwordFieldName, ...rest }: PasswordRepeatElementProps<TFieldValues>): JSX.Element;

declare type AutocompleteElementProps<F extends FieldValues, T, M extends boolean | undefined, D extends boolean | undefined> = {
    name: Path<F>;
    control?: Control<F>;
    options: T[];
    loading?: boolean;
    multiple?: M;
    matchId?: boolean;
    rules?: ControllerProps['rules'];
    required?: boolean;
    label?: TextFieldProps['label'];
    showCheckbox?: boolean;
    autocompleteProps?: Omit<AutocompleteProps<T, M, D, any>, 'name' | 'options' | 'loading' | 'renderInput'>;
    textFieldProps?: Omit<TextFieldProps, 'name' | 'required' | 'label'>;
};
declare type AutoDefault = {
    id: string | number;
    label: string;
};
declare function AutocompleteElement<TFieldValues extends FieldValues>({ textFieldProps, autocompleteProps, name, control, options, loading, showCheckbox, rules, required, multiple, matchId, label }: AutocompleteElementProps<TFieldValues, AutoDefault | string | any, boolean | undefined, boolean | undefined>): JSX.Element;

declare type SliderElementProps<T extends FieldValues> = Omit<SliderProps, 'control'> & {
    name: Path<T>;
    control?: Control<T>;
    label?: string;
    rules?: ControllerProps['rules'];
    parseError?: (error: FieldError) => string;
    required?: boolean;
    formControlProps?: FormControlProps;
};
declare function SliderElement<TFieldValues extends FieldValues>({ name, control, label, rules, parseError, required, formControlProps, ...other }: SliderElementProps<TFieldValues>): JSX.Element;

declare type SingleToggleButtonProps = Omit<ToggleButtonProps, 'value' | 'children'> & {
    id: number | string;
    label: ReactNode;
};
declare type ToggleButtonGroupElementProps<T extends FieldValues> = ToggleButtonGroupProps & {
    required?: boolean;
    label?: string;
    validation?: ControllerProps['rules'];
    name: Path<T>;
    parseError?: (error: FieldError) => string;
    control?: Control<T>;
    options: SingleToggleButtonProps[];
    formLabelProps?: FormLabelProps;
    helperText?: string;
};
declare function ToggleButtonGroupElement<TFieldValues extends FieldValues = FieldValues>({ name, control, label, validation, required, options, parseError, helperText, formLabelProps, ...toggleButtonGroupProps }: ToggleButtonGroupElementProps<TFieldValues>): JSX.Element;

export { AutocompleteElement, AutocompleteElementProps, CheckboxButtonGroup, CheckboxButtonGroupProps, CheckboxElement, CheckboxElementProps, DatePickerElement, DatePickerElementProps, DateTimePickerElement, DateTimePickerElementProps, FormContainer, FormContainerProps, MultiSelectElement, MultiSelectElementProps, PasswordElement, PasswordElementProps, PasswordRepeatElement, PasswordRepeatElementProps, RadioButtonGroup, RadioButtonGroupProps, SelectElement, SelectElementProps, SliderElement, SliderElementProps, SwitchElement, SwitchElementProps, TextFieldElement, TextFieldElementProps, TimePickerElement, TimePickerElementProps, ToggleButtonGroupElement, ToggleButtonGroupElementProps };
